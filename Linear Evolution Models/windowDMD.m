% -------------------------------------------------------------------------
% Sliding Window Dynamic Mode Decomposition
%
% In this script we apply the sliding window method of dynamic mode 
% decomposition (DMD) of Dylewsky, Tao, and Kutz (Physical Review E, 2019).
% The method is applied to synthetic data generated by a four-dimensional
% ordinary differential equation and then mixed via a random orthogonal
% matrix.
%
% The script proceeds by first applying standard DMD (see
% Schrodinger_DMD.m and Section 2.1 of the textbook) to the signal. This is 
% used to demonstrate the weakness of the method for multiscale signals. We 
% then follow this with an application of sliding window DMD, which 
% drastically improves the performance in recreating the signal.
%
% To recreate the results from the manuscript, simply load the orthogonal 
% matrix ortho_mat.mat provided in the repository.
%
% This script accompanies Section 2.2 of Data-Driven Methods for
% Dynamic Systems. 
%
% Author: Jason J. Bramburger
% -------------------------------------------------------------------------

% Clean workspace
clear all; close all; clc

%% Generate data 

% Model parameters
eps = 0.01;
delta = 10;

% ODE step parameters
dt = eps/100; % need lots of resolution for fast timescale
tspan = 0:dt:2^6;

% Initial conditions
M = 4; % dimension of ODE
x0 = [0.0; 0.5; 0.0; 0.5];

% Integrate ODE
[t, x] = ode45(@(t,x) rhs(x,delta,eps),tspan,x0);

%% Random mixing of the singals

% Generate random orthogonal matrix
Q = rand(M);
Q = orth( Q.' ).'; % orthogonal rows
Q = Q*diag(2*randi([0, 1],[1 M])-1); % randomly make some components negative as well

% To reproduce results from the textbook load orth_mat.mat
load orth_mat.mat

% Mix signal using the orthogonal matrix
xdat = x*Q;

% Plot multiscale signal
figure(1)
plot(t,xdat(:,1),'k','LineWidth',1)
hold on
plot(t,xdat(:,2),'k','LineWidth',1)
plot(t,xdat(:,3),'k','LineWidth',1)
plot(t,xdat(:,4),'k','LineWidth',1)
xlabel('$t$','interpreter','latex','FontSize',16)
ylabel('$x(t)$','interpreter','latex','FontSize',16)
set(gca,'FontSize',14,'Xlim',[0,tspan(end)])

%% Apply standard DMD to multiscale signal

% Create X and Y matrices
X = xdat(1:end-1,:)';
Y = xdat(2:end,:)';

% DMD matrix
A = Y*pinv(X);
[eV, D] = eig(A); % compute eigenvalues + eigenvectors
mu = diag(D); % extract eigenvalues

% Continuous time eigenvalues for reference
omega = log(mu)/dt;

%% Forecast with DMD

N = length(t);
xforecast = zeros(M,N);
xforecast(:,1) = X(:,1);

% DMD forecast
for m = 1:N-1
    xforecast(:,m+1) = A*xforecast(:,m);
end

% Compare DMD forecast with data
% --> Plotting x_3(t) because the difference is easiest to see
figure(2)
plot(t,xdat(:,3),'k','LineWidth',1)
hold on
plot(t,xforecast(3,:),'Color',[1 69/255 79/255],'LineWidth',1)
xlabel('$t$','interpreter','latex','FontSize',16)
ylabel('$x_3(t)$','interpreter','latex','FontSize',16)
set(gca,'FontSize',14,'Xlim',[0,tspan(end)])

%% ------------------------------------------------------- 
% Begin Windowed DMD
% -------------------------------------------------------

T = 1/dt; % Window width
step = 100; % forward step between windows - used to speed up computations
numWindows = (N-T-1)/step + 1; % subtracting off 1 because N-1 is length of X and Y vectors above
Omega = zeros(M,numWindows);
winMid = zeros(1,numWindows); % track the middle of the window for plotting
windowSolfast = zeros(M,length(t));
windowSolslow = zeros(M,length(t));
GaussSum = zeros(1,length(t)); 
sig = T*dt/8;

% Windowed computations
for k = 1:numWindows
   
   A = Y(:,(k-1)*step + 1:(k-1)*step + T)*pinv(X(:,(k-1)*step + 1:(k-1)*step + T));
   [V, D] = eig(A);
   eV = diag(D);
   Omega(:,k) = sort(abs(log(eV)/dt).^2);
   winMid(k) = t((k-1)*step + T/2); 
   
   % Computing windowed solution with eigen-expansion
   b = pinv(V)*X(:,(k-1)*step + 1); % eigenvector coefficients inspan
   for j = 1:2
       % there is a minus in from of the eigenvalue because it was factored
       % into the Gaussian
       windowSolfast = windowSolfast + (b(j)*V(:,j).*(exp(- ((t - winMid(k)).^2)/sig^2 - 1i*imag(log(eV(j))/dt)*(t - t((k-1)*step + 1)) ) )'  );
       windowSolslow = windowSolslow + (b(j+2)*V(:,j+2).*(exp(- ((t - winMid(k)).^2)/sig^2 - 1i*imag(log(eV(j+2))/dt)*(t - t((k-1)*step + 1)) ) )'  );
   end
   GaussSum = GaussSum + exp(- (t - winMid(k)).^2/sig^2 )';
    
end

windowSolfast = windowSolfast./GaussSum;
windowSolslow = windowSolslow./GaussSum;

% Put slow and fast together to get full solution
windowSol = windowSolfast + windowSolslow;

%% Plot Frequency Results

% Frequency clusters
figure(3)
clf
plot(winMid,Omega(1,:),'.','Color',[36/255 122/255 254/255],'MarkerSize',20)
hold on
plot(winMid,Omega(3,:),'.','Color',[0 168/255 0],'MarkerSize',20)
xlabel('Window Center','interpreter','latex','FontSize',16)
ylabel('$|\omega_j^{(k)}|^2$','interpreter','latex','FontSize',16)
set(gca,'FontSize',14,'Xlim',[0,tspan(end)])

% kmedoids for identifying clusters (indices at idx) and centroids of the clusters (C)
[idx, C] = kmeans(Omega(:),2);
C = sort(C);

% Zoom of clusters with centroids plotted
figure(4)
clf
subplot(2,1,1)
plot(winMid,Omega(3,:),'.','Color',[0 168/255 0],'MarkerSize',15)
hold on
plot(winMid,C(2)*ones(1,numWindows),'--','Color',[1 69/255 79/255],'LineWidth',4)
xlabel('Window Center','interpreter','latex','FontSize',16)
ylabel('$|\omega_j^{(k)}|^2$','interpreter','latex','FontSize',16)
set(gca,'FontSize',14,'Xlim',[0,tspan(end)])

subplot(2,1,2)
plot(winMid,Omega(1,:),'.','Color',[36/255 122/255 254/255],'MarkerSize',15)
hold on
plot(winMid,C(1)*ones(1,numWindows),'--','Color',[1 69/255 79/255],'LineWidth',4)
xlabel('Window Center','interpreter','latex','FontSize',16)
ylabel('$|\omega_j^{(k)}|^2$','interpreter','latex','FontSize',16)
set(gca,'FontSize',14,'Xlim',[0,tspan(end)])

%% Plot Signal Reconstruction Results

% Reconstructed signals using sliding window DMD
figure(5)
clf
plot(t,xdat,'k.','LineWidth',2)
hold on
plot(t,real(windowSol),'Color',[1 69/255 79/255],'LineWidth',1)
xlabel('$t$','interpreter','latex','FontSize',16)
ylabel('$x(t)$','interpreter','latex','FontSize',16)
set(gca,'FontSize',14,'Xlim',[0,tspan(end)])

% Separating out slow and fast components
figure(6)
clf
plot(t,xdat,'k.','LineWidth',1)
hold on
plot(t,real(windowSolslow),'Color',[36/255 122/255 254/255],'LineWidth',2)
plot(t,real(windowSolfast),'Color',[0 168/255 0],'LineWidth',1)
xlabel('$t$','interpreter','latex','FontSize',16)
ylabel('$x(t)$','interpreter','latex','FontSize',16)
set(gca,'FontSize',14,'Xlim',[0,tspan(end)])



%% ODE right-hand-side

function dx = rhs(x,delta,eps)
    x1 = x(1); 
    x2 = x(2); 
    y1 = x(3); 
    y2 = x(4);
    
    dx=[x2; -y1^2 * x1^3; y2; -eps^(-1)*y1 - delta*y1^3];
end